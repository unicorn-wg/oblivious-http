{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-01-26T00:09:59.515343+00:00",
  "repo": "unicorn-wg/oblivious-http",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU3ODY1NDIwMjQ=",
      "title": "Informational status codes",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/2",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We aren't really able to carry informational status codes using this form of encapsulation.\r\n\r\nSure, we could encode an informational status as a new message, but we don't have anywhere to include it, except as the content of a response, along with the final status code.  That might not be helpful if you consider things like 100-continue.\r\n\r\nMy recommendation is to make this limitation clear and prohibit the use of 100-continue.\r\n",
      "createdAt": "2021-01-15T05:13:15Z",
      "updatedAt": "2021-01-22T02:35:34Z",
      "closedAt": "2021-01-22T02:35:34Z",
      "comments": []
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU3ODY1OTg2NDU=",
      "title": "Padding",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/4",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The format I've sketched out for binary messages can be padded with zeros without needing a separate padding field.  That's probably a feature worth mentioning in both drafts.",
      "createdAt": "2021-01-15T06:27:26Z",
      "updatedAt": "2021-01-15T06:27:26Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU3ODY2MTA2MjQ=",
      "title": "y u no proxy?",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/5",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We need to explain the advantages of this over making a new connection via a proxy for every request.  That is largely performance-related: TLS costs a lot more than this does, both in terms of round trips (1 extra), in terms of bytes exchanged (waaay more), and in terms of CPU cycles spent doing crypto (2x at least).",
      "createdAt": "2021-01-15T06:36:13Z",
      "updatedAt": "2021-01-18T21:43:07Z",
      "closedAt": "2021-01-18T21:43:07Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU3ODY2MjE2NDM=",
      "title": "What trust does each entity place in other entities?",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/6",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This also needs to talk about how different entities might authenticate others that are involved in order to back that trust with something more concrete.\r\n\r\nSpamming/DoS: request resources trust proxy resources not to pass on spam; same for target resources and request resources.  A request resource might want to authenticate a proxy resource so that they can limit the proxies they accept.  A target resource might do the same to request resources, but a more plausible deployment model is those two being the same entity (something that you can't have with proxy/request). \r\n\r\nInformation protection: clients trust proxy resources not to give their information to request resources.  That is, not their IP address, nor any strong indication that two requests come from the same entity.  (We have seen cases where people think this might be required for anti-abuse, but I think that ignores the spamming/DoS relationship to the detriment of user privacy.  This might be a fun discussion.)",
      "createdAt": "2021-01-15T06:41:33Z",
      "updatedAt": "2021-01-18T21:43:07Z",
      "closedAt": "2021-01-18T21:43:07Z",
      "comments": []
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU3ODc4NTY3MDU=",
      "title": "Consider nonces",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/8",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In our discussion of #7, @chris-wood and I explored the ways in which nonce reuse might occur.\r\n\r\nThe problem arises if the client reuses `enc`.  This leads to nonce reuse on the request for sure.  However, if the request is the same, the problem shifts to the response.  Unless the response is also identical, we get nonce reuse on the response instead.\r\n\r\nWe then discussed options for safeguarding against this.\r\n\r\nAs the client is expected to include randomness in its derivation of its key, it seems like the failing is not something that adding extra steps at the client will address.  So I don't think that adding anything to the request really helps.  \r\n\r\nSeparately, HPKE code is supposed to be stateful.  Reuse of a context should result in the sequence number increasing, leading to a nonce that the server cannot reconstruct (unless it also counts and does trial decryption, but that's two bad actors).  That should ensure that the client doesn't use the same nonce twice.  You really have to have bad randomness at the client to get into a deliberate nonce reuse scenario if you trust that the HPKE implementation is properly stateful.\r\n\r\nHowever, a response that is generated in response to a replayed request is something I am concerned about.  We know that HTTP clients routinely do, even if the request is marked POST.  So some protection here is warranted.  For this, I'm going to suggest that we change from salting based on the request to salting based on `enc || new-randomness`.  Hashing the entire message is likely to be very expensive, both in terms of cycles, but also in terms of state.  The public key should be enough to ensure the binding in the case where a client doesn't reuse the context, and the new randomness should help in case of reuse.\r\n\r\nI think that it's OK to use 128 bits of extra randomness here, but we don't have a handy constant to hang that on.  Nn is 96, Nk could be 128 or 256 depending on the AEAD.  What we really want is the block size, but that isn't a property that is exposed anywhere.",
      "createdAt": "2021-01-18T01:57:54Z",
      "updatedAt": "2021-01-18T23:43:12Z",
      "closedAt": "2021-01-18T23:43:12Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is the right design on balance. If we were more conservative, we could include the entire client request (including `enc`), but that doesn't really hedge against the misuse scenario. I'll propose text in #9.",
          "createdAt": "2021-01-18T15:20:52Z",
          "updatedAt": "2021-01-18T15:20:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Fixed in #11.",
          "createdAt": "2021-01-18T23:43:01Z",
          "updatedAt": "2021-01-18T23:43:01Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU3ODg1Njk0NDU=",
      "title": "Key ID length authentication",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/12",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should the key ID length be explicitly authenticated, e.g., by including it in the AAD, or should the AEAD implicitly authenticate things? Unclear!",
      "createdAt": "2021-01-18T21:59:15Z",
      "updatedAt": "2021-01-23T01:55:40Z",
      "closedAt": "2021-01-23T01:55:40Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Should we even bother with an AAD at all?  The best reason is that the keyID determines which key the server uses, which is information that factors into decisions.\r\n\r\n(A related question might be why doesn't HPKE take variables as input so that things like key identifiers can be integrated into the key schedule.)",
          "createdAt": "2021-01-18T22:01:51Z",
          "updatedAt": "2021-01-18T22:01:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Should we even bother with an AAD at all? The best reason is that the keyID determines which key the server uses, which is information that factors into decisions.\r\n\r\nMy take: yes. I need to think through the implications of no additional authentication at all, and in the mean time, I'd be more comfortable with simply authenticating everything possible.\r\n\r\n> (A related question might be why doesn't HPKE take variables as input so that things like key identifiers can be integrated into the key schedule.)\r\n\r\nI think it was discussed, but it makes the interface a mess. And since applications can accomplish the same thing by shoving what they want authenticated into the AAD, it was voted down.",
          "createdAt": "2021-01-18T22:07:44Z",
          "updatedAt": "2021-01-18T22:07:44Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Yeah, you and I both know that putting stuff in the AAD isn't a real substitute for having it in the key schedule.  I completely understand how this would mess with the purity of the design, but TLS managed by wrapping its labels better (which also addresses a known problem with HKDF not being injective).",
          "createdAt": "2021-01-18T22:11:09Z",
          "updatedAt": "2021-01-18T22:11:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Fixed by virtue of making the key ID fixed length in #22.",
          "createdAt": "2021-01-22T03:45:06Z",
          "updatedAt": "2021-01-22T03:45:06Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU3ODg1Njk2OTY=",
      "title": "AAD for requests",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/13",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Right now, @chris-wood and I are debating what I think might be three options:\r\n\r\n1. No AAD\r\n2. keyID\r\n3. length-prefixed keyID\r\n\r\nThe response includes no AAD.",
      "createdAt": "2021-01-18T21:59:56Z",
      "updatedAt": "2021-01-18T22:00:27Z",
      "closedAt": "2021-01-18T22:00:27Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Oops,  #12.",
          "createdAt": "2021-01-18T22:00:16Z",
          "updatedAt": "2021-01-18T22:00:16Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU3ODg4OTAxMDM=",
      "title": "Format for server key information",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/16",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Right now we just use words for this, but we might want to define a format that includes keyID, KEM, KDF, AEAD, and pk for the server. A media type for this might be good. Given the general applicability of this, it might want to be a separate document.",
      "createdAt": "2021-01-19T10:14:24Z",
      "updatedAt": "2021-01-23T02:03:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "I would suggest we steal either the MLS or the ECH format.\n\nOn Tue, Jan 19, 2021 at 2:14 AM Martin Thomson <notifications@github.com>\nwrote:\n\n> Right now we just use words for this, but we might want to define a format\n> that includes keyID, KEM, KDF, AEAD, and pk for the server. A media type\n> for this might be good. Given the general applicability of this, it might\n> want to be a separate document.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/unicorn-wg/oblivious-http/issues/16>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIKWUAMCATTJF2WJ4S3S2VLRBANCNFSM4WIRJ2YA>\n> .\n>\n",
          "createdAt": "2021-01-19T13:29:51Z",
          "updatedAt": "2021-01-19T13:29:51Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "That seems ideal.  I was more thinking about how we might represent this information as a media type or in a header field.  Right now, we're assuming configuration rather than discovery, but for things like key rotation, it could be helpful to include a way to provide updated keys.\r\n\r\nOne way this might help to provide a way for an oblivious request resource to indicate some of the keys that can be used to talk to it.",
          "createdAt": "2021-01-19T21:44:58Z",
          "updatedAt": "2021-01-19T21:44:58Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I looked at the ECH format and it wasn't suitable.  It doesn't include a key identifier (it uses that hashing thing for identification) and it relies on TLS signaling the KDF and AEAD that was chosen.  It also includes stuff we don't need.\r\n\r\nThe MLS KeyPackage is even more divergent from our needs.  MLS remaps the KEM, KDF, and AEAD identifiers and includes a bunch of other stuff we don't need.\r\n\r\nWhat I've implemented, which can easily change is this:\r\n\r\n```\r\nConfig {\r\n  Key ID Length (i),\r\n  Key ID (..),\r\n  KEM (16),\r\n  KDF (16),\r\n  AEAD (16),\r\n  Public Key (..), # remainder\r\n}\r\n```\r\n\r\nHowever, I think that it makes sense to have a format that wraps multiple keys, say:\r\n\r\n```\r\nPrefixed Config {\r\n  Config Length (i),\r\n  Config (..),\r\n}\r\nOblivious Request Resource Config {\r\n  PrefixedConfig (..) ...,\r\n}\r\n```\r\n\r\nThis would allow an oblivious request resource to advertise multiple keys.\r\n\r\nDrawbacks:\r\n\r\n* This is not space efficient: if the same key supports multiple configurations, then this will require that the key be repeated multiple times, and with a different key identifier for each.  But I'm going to suggest that gzip can solve that problem for us.\r\n\r\n* There is no way to annotate individual keys.  This might complicate the addition of per-key expiration times.  My initial view is that once replacement keys are available, you don't need to advertise other keys, even if you still accept requests for some time.\r\n\r\nAll told, this is starting to smell like a substantial enough piece to warrant a separate document.",
          "createdAt": "2021-01-21T00:15:47Z",
          "updatedAt": "2021-01-21T00:15:47Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "Hmm... I'm not sure I agree with this analysis. This seems to me that it's\nisomorphic to the ECH situation, you're just making a different design\ntradeoff about where to carry the KDF and AEAD, for instance. What stops\nyou from using the hashing thing and carrying the KDF and AEAD in this\nbrand new format?\n\n\nOn Wed, Jan 20, 2021 at 4:16 PM Martin Thomson <notifications@github.com>\nwrote:\n\n> I looked at the ECH format and it wasn't suitable. It doesn't include a\n> key identifier (it uses that hashing thing for identification) and it\n> relies on TLS signaling the KDF and AEAD that was chosen. It also includes\n> stuff we don't need.\n>\n> The MLS KeyPackage is even more divergent from our needs. MLS remaps the\n> KEM, KDF, and AEAD identifiers and includes a bunch of other stuff we don't\n> need.\n>\n> What I've implemented, which can easily change is this:\n>\n> Config {\n>   Key ID Length (i),\n>   Key ID (..),\n>   KEM (16),\n>   KDF (16),\n>   AEAD (16),\n>   Public Key (..), # remainder\n> }\n>\n> However, I think that it makes sense to have a format that wraps multiple\n> keys, say:\n>\n> Prefixed Config {\n>   Config Length (i),\n>   Config (..),\n> }\n> Oblivious Request Resource Config {\n>   PrefixedConfig (..) ...,\n> }\n>\n> This would allow an oblivious request resource to advertise multiple keys.\n>\n> Drawbacks:\n>\n>    -\n>\n>    This is not space efficient: if the same key supports multiple\n>    configurations, then this will require that the key be repeated multiple\n>    times, and with a different key identifier for each. But I'm going to\n>    suggest that gzip can solve that problem for us.\n>    -\n>\n>    There is no way to annotate individual keys. This might complicate the\n>    addition of per-key expiration times. My initial view is that once\n>    replacement keys are available, you don't need to advertise other keys,\n>    even if you still accept requests for some time.\n>\n> All told, this is starting to smell like a substantial enough piece to\n> warrant a separate document.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/unicorn-wg/oblivious-http/issues/16#issuecomment-764059399>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIL25D37MHIJ254FSHLS25W4FANCNFSM4WIRJ2YA>\n> .\n>\n",
          "createdAt": "2021-01-21T00:27:17Z",
          "updatedAt": "2021-01-21T00:27:17Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "OK, I'm going to try not to react here with how abhorrent the hashing thing is, but I think that it exists primarily to avoid carrying information in the ECH context.\r\n\r\nWe could carry certainly carry KDF and AEAD identifiers separate to the key identifier.  That's a choice that would allow us to reuse the part of the ECH configuration that repeats that piece.  And have multiple combinations of those for the same key identifier.  I don't care so much about that piece, though in practice you can get that by packing those fields into the key identifier.\r\n\r\nThe pieces we really don't want are the public name (which means nothing in this context) and extensions.  This is not something that needs extending arbitrarily.",
          "createdAt": "2021-01-21T00:33:07Z",
          "updatedAt": "2021-01-21T00:33:07Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "On Wed, Jan 20, 2021 at 4:33 PM Martin Thomson <notifications@github.com>\r\nwrote:\r\n\r\n> OK, I'm going to try not to react here with how abhorrent the hashing\r\n> thing is, but I think that it exists primarily to avoid carrying\r\n> information in the ECH context.\r\n>\r\n> We could carry certainly carry KDF and AEAD identifiers separate to the\r\n> key identifier. That's a choice that would allow us to reuse the part of\r\n> the ECH configuration that repeats that piece. And have multiple\r\n> combinations of those for the same key identifier. I don't care so much\r\n> about that piece, though in practice you can get that by packing those\r\n> fields into the key identifier.\r\n>\r\nMy point is that the design considerations are no different here than for\r\nECH. As far as I can tell, this simply reflects a different aesthetic\r\npreference. That's fine, but I think consistency of design is useful and\r\nimportant, and so to the extent to which it's just aesthetics we should\r\ncome down to one conclusion and then impose it on both. If that means\r\nchanging ECH, then so be it.\r\n\r\n> The pieces we really don't want are the public name (which means nothing in\r\n> this context)\r\n\r\nI agree with this.\r\n\r\n> and extensions. This is not something that needs extending arbitrarily.\r\n\r\nI don't agree with this. My experience is that more or less whenever we\r\nmake the decision not to leave ourselves extension points we find that we\r\nregret this. In that vein, it's worth noting that we can address the public\r\nname issue by making public name an extension, thus harmonizing the formats\r\nand avoiding the clutter here.\r\n",
          "createdAt": "2021-01-21T00:38:17Z",
          "updatedAt": "2021-01-21T00:39:20Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I value reuse, but not to that extent.  Not when it means a format that has extensions, where in one context extension A is mandatory, but in another context extension B is mandatory instead.  And all the mess that comes with extension processing to boot.",
          "createdAt": "2021-01-21T00:42:45Z",
          "updatedAt": "2021-01-21T00:42:45Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Oh, and this point:\r\n\r\n> My experience is that more or less whenever we make the decision not to leave ourselves extension points we find that we regret this. \r\n\r\nI would expect to be able to use a different extension point at the next layer up.  That is, define a new media type or whatever.",
          "createdAt": "2021-01-21T00:45:08Z",
          "updatedAt": "2021-01-21T00:45:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "For what it's worth, I would like for ECH and OHTTP to share the same shape of configuration, modulo the unnecessary bits (public name). @martinthomson, can you elaborate on why the client-computed Key ID is, well, abhorrent? :-) ",
          "createdAt": "2021-01-21T16:59:33Z",
          "updatedAt": "2021-01-21T16:59:33Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "While I don't agree with MT about extensions, perhaps we could factor out\nthe common pieces into a component that could be used by both ECH and OHTTP\ncould use -- and maybe even MLS.\n\nOn Thu, Jan 21, 2021 at 8:59 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> For what it's worth, I would like for ECH and OHTTP to share the same\n> shape of configuration, modulo the unnecessary bits (public name).\n> @martinthomson <https://github.com/martinthomson>, can you elaborate on\n> why the client-computed Key ID is, well, abhorrent? :-)\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/unicorn-wg/oblivious-http/issues/16#issuecomment-764792760>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIO53S22RAQSMK4SYRDS3BMQLANCNFSM4WIRJ2YA>\n> .\n>\n",
          "createdAt": "2021-01-21T17:12:58Z",
          "updatedAt": "2021-01-21T17:12:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "So, a server-chosen key ID does seem attractive, for a number of reasons:\r\n\r\n- Deployment-specific flexibility in the ID -> key mapping\r\n- Avoids hash computation (and algorithm choice) on clients\r\n\r\nHowever, for the sake of exploration, let's say a server wants to publish two configs -- one for AES and another for ChaCha. Clients would obtain this set of of configs... somehow... and make a choice between the two based on their preferences (do they support AES intrinsics?). Let's say an attacker stripped the config with AES from the response to client, forcing it to use ChaCha. The client's Key ID signal does not indicate to the server that the chosen key was made from an incomplete view of the keys. Is this a problem? Perhaps not for AEAD algorithms we care about, but what about in a future world where one key carries a PQ KEM public key and another carries a classical KEM public key? \r\n\r\nIf we think KEM key selection is a problem, then it seems there are a couple ways to address this:\r\n\r\n1. Have clients signal to servers their view of the config set (as is done in ECH with the config_id being computed as a hash of the ECHConfig)\r\n2. Ensure attackers can't interfere with client view of configs\r\n\r\nIf OHTTP configs are published in DNS (I'm not necessarily advocating for this), then (1) seems preferable. If OHTTP configs are fetched directly from the request resource, then perhaps (2) applies?\r\n\r\nI guess the representation of the key ID depends on the threat model, which isn't surprising. :-)\r\n\r\n@ekr, what do you think?",
          "createdAt": "2021-01-21T17:59:31Z",
          "updatedAt": "2021-01-21T17:59:45Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "I spent some time looking back at the history of ECH. It turns out that I originally had a key id and then Kazuho proposed removing it, mostly on the grounds that it was easier to manage with a unique value. It seems like the situation is basically the same here for O-HTTP as for ECH, so we should converge on a common answer whatever that is.\r\n\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/43\r\n\r\nWRT the question of negotiation, ISTM that that's a function of folding the entire configuration into the transcript, and so obviously another identifier is needed if you want to refer to a specific component in the configuration, whether that's a key or a config instance or whatever.\r\n\r\n",
          "createdAt": "2021-01-21T21:48:39Z",
          "updatedAt": "2021-01-21T21:48:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> WRT the question of negotiation, ISTM that that's a function of folding the entire configuration into the transcript, and so obviously another identifier is needed if you want to refer to a specific component in the configuration, whether that's a key or a config instance or whatever.\r\n\r\nTo clarify, are you suggesting possibly folding the entire config set into the transcript and then identifying one specific config in that set (via key id)? ",
          "createdAt": "2021-01-21T21:54:20Z",
          "updatedAt": "2021-01-21T21:54:20Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "If you're concerned about downgrade, I think it's the only way. Though of\ncourse at that point the client has already sent the information, so the\nvalue is limited.\n\nOn Thu, Jan 21, 2021 at 1:54 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> WRT the question of negotiation, ISTM that that's a function of folding\n> the entire configuration into the transcript, and so obviously another\n> identifier is needed if you want to refer to a specific component in the\n> configuration, whether that's a key or a config instance or whatever.\n>\n> To clarify, are you suggesting possibly folding the entire config set into\n> the transcript and then identifying one specific config in that set (via\n> key id)?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/unicorn-wg/oblivious-http/issues/16#issuecomment-764965967>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIO7HC7LXZ25IM3NJQ3S3CPBVANCNFSM4WIRJ2YA>\n> .\n>\n",
          "createdAt": "2021-01-21T22:20:08Z",
          "updatedAt": "2021-01-21T22:20:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, that's a good point. So perhaps there's not much we can do about downgrade other than ensure integrity for the config set?",
          "createdAt": "2021-01-21T22:22:40Z",
          "updatedAt": "2021-01-21T22:22:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Documented the agreed format in #24.  We've still open questions about the extent to which this and ECH can be harmonized, so I'll open a separate issue to ensure that happens.",
          "createdAt": "2021-01-23T02:03:48Z",
          "updatedAt": "2021-01-23T02:03:48Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU3OTA2MDcxMzM=",
      "title": "Discovery",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/19",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This probably covers a bunch of things, so I'll start with a few things that might want to be discovered automatically:\r\n\r\n1. Clients might want to ask the oblivious proxy resource which oblivious request resource it forwards to.\r\n2. Clients might want to learn about which oblivious target resources a particular oblivious request resource is willing to forward to.\r\n3. Clients might want to learn automatically about the public keys the oblivious request resource has (along with key identifiers, see #16).\r\n4. Clients might want to ask about the oblivious proxy resources that forward to a particular oblivious request resource.  This is a little tricky, because clients will need to exercise discretion in selecting from this set.  This also risks exposing the existence of DoS exemption agreements between the oblivious request resource server and the oblivious proxy resource server.\r\n5. Clients might want to ask the oblivious target resource for an oblivious request resource (or by extension oblivious proxy resource) that it can use to reach that resource.\r\n\r\nIf you look at this as link relations, this is two forward links, a key configuration, and two backward links.  Defining link relation types for this might be a way to address this.  Assuming that we also define a media type for a key configuration format, that is.\r\n",
      "createdAt": "2021-01-21T01:45:10Z",
      "updatedAt": "2021-01-21T01:45:10Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU3OTA2MDk1NTI=",
      "title": "Multiple KDF/AEAD tuples",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/20",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Splitting this from #16.\r\n\r\nIt seems likely that a single KEM key will support multiple KDF or AEAD options (NSS will soon support 3 of the former, and 2 of the latter, maybe 3 of each).  Having a configuration that includes a single set of (KEM, key, and key identifier) with a list of KDF+AEAD pairs, akin to ECH, would make it easier to support that sort of deployment.  Without that, key identifiers need to carry information about the KDF and AEAD.\r\n\r\nTo support this, the format needs to be adjusted to carry the KDF and AEAD identifier.  In doing so, we probably want to encode the choice of KDF and AEAD in the key schedule or AAD accordingly.",
      "createdAt": "2021-01-21T01:50:19Z",
      "updatedAt": "2021-01-23T01:55:40Z",
      "closedAt": "2021-01-23T01:55:40Z",
      "comments": []
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU3OTE1NjI4ODc=",
      "title": "Document key configuration format",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/21",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "And document the requirements for this format (namely that it be authenticated and attributed to the oblivious request resource).",
      "createdAt": "2021-01-21T23:19:21Z",
      "updatedAt": "2021-01-23T01:46:47Z",
      "closedAt": "2021-01-23T01:46:47Z",
      "comments": []
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU3OTE2NDM4MTg=",
      "title": "Indicating that the key wasn't known",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/23",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "If the key identifier isn't known to the oblivious request resource, or the message can't be decrypted, it probably wants to send a clear signal.  The signal is definitely not encapsulated at that point, so clients have limited options available to them.\r\n\r\nAs a first-order suggestion, a 4xx status code generally indicates to the client that it might want to review the information it used.  However, more specific error codes might help in specific cases that we deem important or common.  Top of the list: when the identified key has been decommissioned.",
      "createdAt": "2021-01-22T02:25:01Z",
      "updatedAt": "2021-01-23T01:46:24Z",
      "closedAt": "2021-01-23T01:46:24Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "How does [422 (Unprocessable Content)](https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#status.422) sound in terms of saying \"the content was unusable\".  We could go further and recommend the use of [RFC 7807](https://tools.ietf.org/html/rfc7807) if you think more detail is needed.",
          "createdAt": "2021-01-22T03:44:27Z",
          "updatedAt": "2021-01-22T03:44:27Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU3OTI0MDg5OTU=",
      "title": "Ensure key configuration matches ECH",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/27",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We are proposing alignment, but we need to make sure that happens.",
      "createdAt": "2021-01-23T02:04:17Z",
      "updatedAt": "2021-01-23T02:04:17Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU3OTM3ODgzMDA=",
      "title": "The length of the public key is fixed",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/31",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We currently length-prefix it, but we don't *have* to.  Think about this a little.",
      "createdAt": "2021-01-25T23:00:15Z",
      "updatedAt": "2021-01-25T23:00:15Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU3OTM3OTc3ODU=",
      "title": "Include KEMID in Encapsulated Request",
      "url": "https://github.com/unicorn-wg/oblivious-http/issues/32",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, an encapsulated request carries a key ID which maps to a KEM key that determines the size of the encapsulated public key in a request. This means that code parsing a request needs to know the ID -> KEM mapping in order to parse things correctly, which is somewhat annoying. I propose we add KEMID to the request so that this mapping isn't needed to just parse the message. As a bonus, that would also fold in the KEMID explicitly into the AAD alongside the KDFID and AEADID. ",
      "createdAt": "2021-01-25T23:21:13Z",
      "updatedAt": "2021-01-25T23:21:13Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU1MzI5NjA4",
      "title": "Overview",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/1",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-15T01:38:01Z",
      "updatedAt": "2021-01-18T22:15:16Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "501f54803ff2879722decce1041bac235bf74dcd",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "overview",
      "headRefOid": "3ffe08d009791ae96e719ba6c14cdb2161ae49e4",
      "closedAt": "2021-01-15T17:15:52Z",
      "mergedAt": "2021-01-15T17:15:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fab065c185f6dcb9d11965556a2a71d668a4e365"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NDQ4Mjk4",
          "commit": {
            "abbreviatedOid": "3ffe08d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-15T17:15:43Z",
          "updatedAt": "2021-01-15T17:15:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU1NDI2NTA2",
      "title": "Message format",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/3",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is fully-featured, which is a little awkward.  We can probably trim this down a little once we have a better handle on the requirements.",
      "createdAt": "2021-01-15T06:01:46Z",
      "updatedAt": "2021-01-23T01:50:20Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "095341dc8acf1af51f423957ccb3cb6e45f40c8c",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "message-format",
      "headRefOid": "96004ecd61b917a5a36b0c9444afb3ec754b1218",
      "closedAt": "2021-01-23T01:50:19Z",
      "mergedAt": "2021-01-23T01:50:19Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "6e86e49665a5d42364180ffde2c83919d4201e50"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson is the idea here that padding might just be a separate field for each (un)known-length message?",
          "createdAt": "2021-01-18T00:19:46Z",
          "updatedAt": "2021-01-18T00:19:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Not sure if you meant to ask this on #4 instead.  The idea I had for padding is that the format as described is self-delimiting.  (Actually, it was accidental, and I only realized that it worked that way after coming back and thinking about padding.)\r\n\r\nTherefore, you can just add padding at the end.  We can mandate the use of zero bytes, which works for the truncated message syntax I suggest here.",
          "createdAt": "2021-01-18T00:39:57Z",
          "updatedAt": "2021-01-18T00:39:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczNTA2NDIz",
          "commit": {
            "abbreviatedOid": "2cdb3b9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Initial pass complete. I think I grok this, but I need to implement it to make sure. (Feel free to merge anyhow.)",
          "createdAt": "2021-01-21T16:25:17Z",
          "updatedAt": "2021-01-21T16:43:38Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nincluding the application of authenticated encryption.\r\n```\r\n\r\n... to not encourage folks to authenticate without encrypting. :) ",
              "createdAt": "2021-01-21T16:25:17Z",
              "updatedAt": "2021-01-23T01:49:09Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nThis document uses terminology from HTTP ({{!HTTP}}) and notation from QUIC ({{!QUIC=I-D.ietf-quic-transport}}).\r\n```",
              "createdAt": "2021-01-21T16:26:28Z",
              "updatedAt": "2021-01-23T01:49:09Z"
            },
            {
              "originalPosition": 221,
              "body": "```suggestion\r\nthe final status code is encoded.\r\n```",
              "createdAt": "2021-01-21T16:40:39Z",
              "updatedAt": "2021-01-23T01:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzA2NTE2",
          "commit": {
            "abbreviatedOid": "7e9bc64"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-23T00:18:13Z",
          "updatedAt": "2021-01-23T00:32:00Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nprotocol. This enables the transformation of entire messages,\r\n```",
              "createdAt": "2021-01-23T00:18:13Z",
              "updatedAt": "2021-01-23T01:49:09Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n  lengths are not known when encoding starts.\r\n```",
              "createdAt": "2021-01-23T00:19:11Z",
              "updatedAt": "2021-01-23T01:49:09Z"
            },
            {
              "originalPosition": 72,
              "body": "What's the meaning of the extra `...` on this line? That it is optional?",
              "createdAt": "2021-01-23T00:22:41Z",
              "updatedAt": "2021-01-23T01:49:09Z"
            },
            {
              "originalPosition": 194,
              "body": "```suggestion\r\napply to the construction of these values. However, where the `:authority`\r\n```",
              "createdAt": "2021-01-23T00:28:01Z",
              "updatedAt": "2021-01-23T01:49:09Z"
            },
            {
              "originalPosition": 195,
              "body": "I like this solution \ud83d\udc4d ",
              "createdAt": "2021-01-23T00:28:19Z",
              "updatedAt": "2021-01-23T01:49:09Z"
            },
            {
              "originalPosition": 268,
              "body": "Do we see a way forward to have a binary encoding of structured fields? While we don't need to specify that here, it'd be nice to leave it open.",
              "createdAt": "2021-01-23T00:31:15Z",
              "updatedAt": "2021-01-23T01:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzA5ODY0",
          "commit": {
            "abbreviatedOid": "7e9bc64"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-23T00:33:03Z",
          "updatedAt": "2021-01-23T00:33:03Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "It means the field is repeated one or more times (I stumbled across this myself).",
              "createdAt": "2021-01-23T00:33:03Z",
              "updatedAt": "2021-01-23T01:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzEwMDg5",
          "commit": {
            "abbreviatedOid": "7e9bc64"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-23T00:34:04Z",
          "updatedAt": "2021-01-23T00:34:04Z",
          "comments": [
            {
              "originalPosition": 268,
              "body": "Does anything need to change to accommodate them here? I figured they'd just be values with a different encoding.",
              "createdAt": "2021-01-23T00:34:04Z",
              "updatedAt": "2021-01-23T01:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzIyMjc0",
          "commit": {
            "abbreviatedOid": "7e9bc64"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-23T01:48:01Z",
          "updatedAt": "2021-01-23T01:49:17Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "zero or more, yeah.",
              "createdAt": "2021-01-23T01:48:01Z",
              "updatedAt": "2021-01-23T01:49:17Z"
            },
            {
              "originalPosition": 268,
              "body": "A new format is what I was thinking, or maybe use the next bit in the framing indicator.  The latter has some risks though.",
              "createdAt": "2021-01-23T01:48:36Z",
              "updatedAt": "2021-01-23T01:49:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU1ODcwMDUw",
      "title": "Port and modify ODoH encapsulation details.",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/7",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is mostly a port from ODoH to start. We can modify/tweak as needed going forward.",
      "createdAt": "2021-01-15T18:21:04Z",
      "updatedAt": "2021-01-18T22:15:14Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "fab065c185f6dcb9d11965556a2a71d668a4e365",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "caw/first-hpke",
      "headRefOid": "008247cf1dfca4e413bc03ce33c1081e716c8055",
      "closedAt": "2021-01-18T00:04:32Z",
      "mergedAt": "2021-01-18T00:04:32Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "8bda1a4db04a3b407e2ddfa9674d7b4a458db048"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NTY2Mzg5",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T19:38:51Z",
          "updatedAt": "2021-01-15T19:38:51Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Why not describe this above where the struct with padding is defined?",
              "createdAt": "2021-01-15T19:38:51Z",
              "updatedAt": "2021-01-15T19:38:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NTY2NTA2",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-15T19:39:03Z",
          "updatedAt": "2021-01-15T19:39:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NTY5Mzgz",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T19:43:28Z",
          "updatedAt": "2021-01-15T19:43:28Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "I left it here in case we wanted more details (recommended padding policy a la ECH?). We can move it around, though.",
              "createdAt": "2021-01-15T19:43:28Z",
              "updatedAt": "2021-01-15T19:43:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTA4Mzgy",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Lots of things to follow up on here, but I'm going to merge and we can iron those out later.  We need a starting point and this is a good starting point.",
          "createdAt": "2021-01-17T23:43:48Z",
          "updatedAt": "2021-01-18T00:04:14Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "See #4 here. :)",
              "createdAt": "2021-01-17T23:43:48Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 7,
              "body": "I'll look after that soon.",
              "createdAt": "2021-01-17T23:44:01Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\n  Key Identifier (..),\r\n```\r\n\r\nI'm so glad you included a key identifier.  There wasn't one in the ODoH draft I was reading and it was bothering me.\r\n\r\nHowever, I don't think that you need to include a key identifier in responses.  The request/response thing will ensure that there is no possibility for confusion.  That means that the response can just be the output of aead.Seal.",
              "createdAt": "2021-01-17T23:44:59Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 53,
              "body": "To be clear, this does not include the length field, right?",
              "createdAt": "2021-01-17T23:46:07Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 32,
              "body": "I think that we can drop the length prefix for the encrypted blob.",
              "createdAt": "2021-01-17T23:48:21Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 57,
              "body": "I think that you are missing `enc` here.  Isn't the message:\r\n\r\n```\r\nkeyID.length || keyID || enc || encrypted_msg\r\n```\r\n\r\nReading the -07 HPKE draft, it doesn't include `enc` in the output of `context.Seal`.  Should it?",
              "createdAt": "2021-01-17T23:49:04Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 65,
              "body": "The AAD  is `0x1 || keyID`.",
              "createdAt": "2021-01-17T23:52:44Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 45,
              "body": "This needs to mention the string \"request\".",
              "createdAt": "2021-01-17T23:54:03Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nct = context.Seal(aad, msg)\r\nencrypted_msg = enc || ct\r\n```",
              "createdAt": "2021-01-17T23:54:48Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 46,
              "body": "If you want to match the pseudocode, add a step 2:\r\n\r\n```suggestion\r\n2. Construct additional associated data, `aad`, by prepending a single byte with a value 0x01 to the key identifier. The key identifier length is not included in the AAD.\r\n3. Encrypt (seal) `msg` with `aad` as associated data using `context`, yielding ciphertext `ct`\r\n```",
              "createdAt": "2021-01-17T23:56:22Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 83,
              "body": "This step needs more substance.  The pseudocode is far more complete.",
              "createdAt": "2021-01-17T23:59:15Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 84,
              "body": "Not sure about using an empty key identifier.  The construction of the context does not include the key identifier, so we aren't binding the response to the entire request in any way.  Including the key ID as AAD might do the job.  We don't have to send it.",
              "createdAt": "2021-01-18T00:00:53Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 94,
              "body": "```suggestion\r\nkey = context.Export(\"response key\", Nk)\r\nnonce = context.Export(\"response nonce\", Nn)\r\naad = ???\r\nencrypted_msg = Seal(key, nonce, aad, resp)\r\n```\r\n\r\nMy preference would be to export two values for this.",
              "createdAt": "2021-01-18T00:02:12Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            },
            {
              "originalPosition": 106,
              "body": "I think that we can defer padding to the binary message structure, ultimately.  See #4.",
              "createdAt": "2021-01-18T00:03:17Z",
              "updatedAt": "2021-01-18T00:04:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTExMTUz",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T00:10:09Z",
          "updatedAt": "2021-01-18T00:10:09Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "We considered this for ODoH too, but this removes binding between the response encryption key material and the request. So, in theory, I think it would be possible for an application to mistakenly send the same `enc` to the server, forcing it to derive the same key and nonce, and possibly reuse them for encrypting the response. I think we should bake key/nonce re-use into the encapsulation mechanism, if possible.",
              "createdAt": "2021-01-18T00:10:09Z",
              "updatedAt": "2021-01-18T00:10:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTExNDg1",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T00:13:38Z",
          "updatedAt": "2021-01-18T00:13:38Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Yeah, I was going for brevity in the textual descriptions, but we make it more complete to match the pseudocode. \r\n\r\n> Reading the -07 HPKE draft, it doesn't include enc in the output of context.Seal. Should it?\r\n\r\nI don't think so, since you might want to use the same context for multiple seals but don't want to send `enc` alongside each ciphertext.",
              "createdAt": "2021-01-18T00:13:38Z",
              "updatedAt": "2021-01-18T00:13:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTExNTYy",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T00:14:19Z",
          "updatedAt": "2021-01-18T00:14:20Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Would the length just be inferred as \"rest of message\"? (If we're confident that it's always unambiguous, I'm fine omitting it)",
              "createdAt": "2021-01-18T00:14:19Z",
              "updatedAt": "2021-01-18T00:14:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTExNTk5",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T00:14:43Z",
          "updatedAt": "2021-01-18T00:14:43Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "The intention was for it to include the length and value --`keyID` is a Key Identifier message, which includes the length. ",
              "createdAt": "2021-01-18T00:14:43Z",
              "updatedAt": "2021-01-18T00:14:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTExODY0",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T00:16:55Z",
          "updatedAt": "2021-01-18T00:16:55Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Admittedly it's a bit of YAGNI, so I'm fine dropping it, but there were prior discussions about the response using something other than symmetric encryption, and the key ID \"would help\" there. (No concrete use case now, so let's just drop it.)",
              "createdAt": "2021-01-18T00:16:55Z",
              "updatedAt": "2021-01-18T00:16:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTExODcz",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T00:16:59Z",
          "updatedAt": "2021-01-18T00:16:59Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Oh, I missed the fact that you are including the entire request (?) in the key schedule.  That seems like something that is worth documenting.  I missed it completely.\r\n\r\nHowever, it might be enough to include `enc`, so that you don't have to remember the entire message.",
              "createdAt": "2021-01-18T00:16:59Z",
              "updatedAt": "2021-01-18T00:16:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTExOTEx",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T00:17:20Z",
          "updatedAt": "2021-01-18T00:17:21Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Right, rest of message should do.",
              "createdAt": "2021-01-18T00:17:20Z",
              "updatedAt": "2021-01-18T00:17:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTEyNjAw",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T00:23:20Z",
          "updatedAt": "2021-01-18T00:23:20Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Even `enc` might not be enough, since a client could mistakenly re-use `enc` for more than one request, leading to the nonce/key reuse issue, I think.",
              "createdAt": "2021-01-18T00:23:20Z",
              "updatedAt": "2021-01-18T00:23:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTE0MzE0",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T00:36:34Z",
          "updatedAt": "2021-01-18T00:36:35Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "At that point you have nonce reuse for the request, so any protection you have for the response is far less valuable.",
              "createdAt": "2021-01-18T00:36:35Z",
              "updatedAt": "2021-01-18T00:36:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTIxNDEy",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T01:21:01Z",
          "updatedAt": "2021-01-18T01:21:02Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Hmm, true, though only if the request contents are different, right? Either way, if enc is reused across requests, it seems:\r\n\r\n1. If the request is different, then we have reuse on the request\r\n2. If the request is the same, and the response is different, then we have reuse on the response. \r\n3. If the request and responses are the same, then no reuse\r\n\r\nUnless I'm missing something, (1) seems something we may have to just acknowledge. I don't see a way to prevent it. One might try to include a nonce in the `context` derivation, but if the client reuses `enc`, then it might just reuse that nonce. (ODoH avoided this since the requests always had some entropy in them, and should therefore be different with high probability.)\r\n\r\nSo if we want to focus on (2) and (3), where the requests are the same, then it seems (2) should be the assumed case. (Relying on content to never change seems silly.) And the only way to seemingly prevent that is for the server to contribute randomness to the key derivation. \r\n\r\nGiven that, I see a number of options:\r\n\r\n1. Include request in the key derivation: this doesn't address case (2) above.\r\n2. Include server nonce in the key derivation: this addresses (2), but makes the server entirely responsible for preventing nonce reuse. (Do we trust their randomness?)\r\n3. Include both request and a server nonce in key derivation: this addresses (2), and hedges against bad randomness\r\n\r\nWhat do you think?",
              "createdAt": "2021-01-18T01:21:02Z",
              "updatedAt": "2021-01-18T01:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTI1NzQ0",
          "commit": {
            "abbreviatedOid": "008247c"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T01:44:13Z",
          "updatedAt": "2021-01-18T01:44:13Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I think that there is no really good answer here.  Given 0-RTT, the risk of request replay seems like we might want to have some sort of nonce.  Having a nonce in both places makes some sense.  Let's open an issue on this rather than continue here though.",
              "createdAt": "2021-01-18T01:44:13Z",
              "updatedAt": "2021-01-18T01:44:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU2NDY3Mzc3",
      "title": "Do some basic cleanup for encapsulation",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/9",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This just expands the text and tries to be explicit about everything.\r\n\r\nThe one change I've included here is a change from 32 to Nsk for the\r\nexported secret.  I think that's in line with the HPKE intent.\r\nConstants make me nervous.",
      "createdAt": "2021-01-18T02:24:29Z",
      "updatedAt": "2021-01-18T22:15:14Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "8bda1a4db04a3b407e2ddfa9674d7b4a458db048",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "cleanup-encapsulation",
      "headRefOid": "9b18c9243821a9e5f6b1804316e140f7d7ee3fd0",
      "closedAt": "2021-01-18T15:23:57Z",
      "mergedAt": "2021-01-18T15:23:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fd90f306ae8d62cd9a4803bc3837ed40772c36e2"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to merge, and then apply my suggestions and the nonce change in a followup PR.",
          "createdAt": "2021-01-18T15:23:53Z",
          "updatedAt": "2021-01-18T15:23:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNTc1MTUw",
          "commit": {
            "abbreviatedOid": "9b18c92"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-18T15:10:08Z",
          "updatedAt": "2021-01-18T15:23:05Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "Hmm, I think the keyID as sent on the wire, which includes the length, should be the AAD. \r\n\r\n```suggestion\r\n   with a value of 0x01 to the key identifier. The key identifier length is\r\n   included in the AAD.\r\n```",
              "createdAt": "2021-01-18T15:10:08Z",
              "updatedAt": "2021-01-18T15:23:05Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\n   `enc` and `ct`, yielding an Encapsulated Request `enc_request`. Note that `enc` is of \r\n    fixed-length, so there is no ambiguity in parsing `enc` and `ct`.\r\n```",
              "createdAt": "2021-01-18T15:12:16Z",
              "updatedAt": "2021-01-18T15:23:05Z"
            },
            {
              "originalPosition": 93,
              "body": "Where is `vencode` defined?",
              "createdAt": "2021-01-18T15:12:39Z",
              "updatedAt": "2021-01-18T15:23:05Z"
            },
            {
              "originalPosition": 93,
              "body": "```suggestion\r\nkeyID_length = vencode(len(keyID)\r\naad = concat(0x01, keyID_length, keyID)\r\nct = context.Seal(aad, request)\r\nenc_request = concat(keyID_length, keyID, enc, ct)\r\n```",
              "createdAt": "2021-01-18T15:14:17Z",
              "updatedAt": "2021-01-18T15:23:05Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\n   private key, `skR`, corresponding to `keyID`. If no such key exists, the server MUST return\r\n   an error with HTTP status code 401.\r\n```",
              "createdAt": "2021-01-18T15:15:47Z",
              "updatedAt": "2021-01-18T15:23:05Z"
            },
            {
              "originalPosition": 114,
              "body": "```suggestion\r\n   with a value of 0x01 to the key identifier, which includes its length.\r\n```",
              "createdAt": "2021-01-18T15:16:43Z",
              "updatedAt": "2021-01-18T15:23:05Z"
            },
            {
              "originalPosition": 117,
              "body": "```suggestion\r\n   on failure. If decryption fails, the server MUST return an error with HTTP status code 400.\r\n```",
              "createdAt": "2021-01-18T15:17:20Z",
              "updatedAt": "2021-01-18T15:23:06Z"
            },
            {
              "originalPosition": 126,
              "body": "```suggestion\r\naad = concat(0x01, vencode(len(keyID), keyID)\r\n```",
              "createdAt": "2021-01-18T15:17:59Z",
              "updatedAt": "2021-01-18T15:23:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU2NDg5NDcx",
      "title": "Add a bunch of words",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/10",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "A first cut at the intro and the text describing how different entities\r\nmight think about each other.\r\n\r\nAfter all this, I'm running short on stuff that might go in security\r\nconsiderations.  Maybe we should move this new text there so that the\r\nsecurity people can find what they need under a familiar heading.",
      "createdAt": "2021-01-18T03:50:19Z",
      "updatedAt": "2021-01-18T22:15:13Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "8bda1a4db04a3b407e2ddfa9674d7b4a458db048",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "words",
      "headRefOid": "909d6c5d20da1d247a3cd75882816d583e1aec73",
      "closedAt": "2021-01-18T21:43:07Z",
      "mergedAt": "2021-01-18T21:43:07Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "33d57777b41a2bff8be5f4e86e0ae503c3b1d2e1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNjAyOTEx",
          "commit": {
            "abbreviatedOid": "58decd7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This looks good! The security analysis we did for ODoH can be modified and moved over here, in the security considerations, after this change lands. (That change can go into the different attacks that are possible for malicious or HbC proxies or targets.)\r\n\r\nFeel free to merge when ready.",
          "createdAt": "2021-01-18T15:42:20Z",
          "updatedAt": "2021-01-18T15:59:32Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nis significant. Preventing request linkability requires that each request\r\nuse a completely new TLS connection to the server. At a minimum,\r\n```",
              "createdAt": "2021-01-18T15:42:20Z",
              "updatedAt": "2021-01-18T21:42:48Z"
            },
            {
              "originalPosition": 120,
              "body": "Since contexts aren't re-used, I don't think we need to say this.\r\n\r\n```suggestion\r\nto the proxy. \r\n```\r\n",
              "createdAt": "2021-01-18T15:44:54Z",
              "updatedAt": "2021-01-18T21:42:48Z"
            },
            {
              "originalPosition": 133,
              "body": "```suggestion\r\nrequest resource, and forwards responses from the oblivious request resource\r\nback to clients. The proxy MUST forward response status codes without\r\nmodification.\r\n```",
              "createdAt": "2021-01-18T15:48:05Z",
              "updatedAt": "2021-01-18T21:42:48Z"
            },
            {
              "originalPosition": 171,
              "body": "Noting transport-layer since it can't modify the binary messages.\r\n\r\n```suggestion\r\nA proxy can use transport-layer padding to reduce the effectiveness of\r\ntraffic analysis.\r\n```",
              "createdAt": "2021-01-18T15:53:20Z",
              "updatedAt": "2021-01-18T21:42:48Z"
            },
            {
              "originalPosition": 177,
              "body": "I'm not sure we should include this. Clients can't really verify that proxies apply traffic analysis mitigations, so I'm not sure clients would meaningfully take this into account when choosing a proxy.\r\n\r\n```suggestion\r\n```",
              "createdAt": "2021-01-18T15:54:25Z",
              "updatedAt": "2021-01-18T21:42:48Z"
            },
            {
              "originalPosition": 188,
              "body": "Is this enough? What if the response is leaked not via size but via response time? (Victim makes a request whose response is cached, and then attacker sends the same request and tries to observe cache hit/miss.) \r\n\r\n(I really don't love the timing delay stuff, but it seems better to mention the possible risk than not.)\r\n\r\n```suggestion\r\nServers should account for traffic analysis based on response size or generation time.\r\nTechniques such as padding or timing delays can help protect against such attacks;\r\nsee {{ta}}.\r\n```",
              "createdAt": "2021-01-18T15:57:51Z",
              "updatedAt": "2021-01-18T21:42:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNjE4MDQx",
          "commit": {
            "abbreviatedOid": "58decd7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-18T15:59:42Z",
          "updatedAt": "2021-01-18T15:59:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzg5NDI3",
          "commit": {
            "abbreviatedOid": "58decd7"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T21:40:33Z",
          "updatedAt": "2021-01-18T21:42:53Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "I was thinking that this was something we could say because it explains that reuse of a context doesn't necessarily lead to this problem.",
              "createdAt": "2021-01-18T21:40:34Z",
              "updatedAt": "2021-01-18T21:42:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU2ODkyMTE0",
      "title": "Encapsulate the server response with a nonce.",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/11",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Makes some of my suggestions from #9, and addresses #8 in the process.\r\n\r\nFor context, I consider the `keyID` variable to be the wire-encoded (length prefixed) thing, and I tried to clarify that here. I don't feel strongly about the way that's written, but I do think it's important that everything sent on the wire is authenticated, including the keyID length.",
      "createdAt": "2021-01-18T15:40:38Z",
      "updatedAt": "2021-01-18T22:15:12Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "33d57777b41a2bff8be5f4e86e0ae503c3b1d2e1",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "caw/nonces",
      "headRefOid": "a21cda7591a70ffc101b0694077fbdaf507f94bf",
      "closedAt": "2021-01-18T22:02:51Z",
      "mergedAt": "2021-01-18T22:02:51Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "5c44c6dc243fe06314bbcc2be62a06e205a844b4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzg2MjAw",
          "commit": {
            "abbreviatedOid": "e5a1bde"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "The addition of the nonce is good.\r\n\r\nNote sure about the length prefix on `keyID` and equally unsure about Nsk -> Nk.",
          "createdAt": "2021-01-18T21:30:58Z",
          "updatedAt": "2021-01-18T21:38:52Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "So I'm not so sure about this one.  One problem is that the varint encoding is only injective, not bijective.  That means that you can varint encode the length differently for encoding and the AAD if you aren't careful to also keep the length of the length.  That breaks things if implemented as described.\r\n\r\nMy understanding was that an AEAD was required to authenticate the length of the AAD in addition to its content.  GCM does: `S = GHASH_H (A || 0^v || C || 0^u || [len(A)]_64 || [len(C)]_64).`  Can't we rely on that?",
              "createdAt": "2021-01-18T21:30:58Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            },
            {
              "originalPosition": 45,
              "body": "I'm OK with this, but it loses the length-encoding thing (and the lines don't match the numbered list any more).",
              "createdAt": "2021-01-18T21:32:22Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            },
            {
              "originalPosition": 56,
              "body": "I'd like to keep the HTTP-layer stuff to its own section.\r\n\r\n```suggestion\r\n   private key, `skR`, corresponding to `keyID`. If no key exists, the \r\n   server returns an error.\r\n```",
              "createdAt": "2021-01-18T21:33:24Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            },
            {
              "originalPosition": 87,
              "body": "I don't think that this is right.  Can you explain your reasoning?",
              "createdAt": "2021-01-18T21:34:10Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            },
            {
              "originalPosition": 90,
              "body": "I think that we need a separate step to generate the nonce here.",
              "createdAt": "2021-01-18T21:34:57Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            },
            {
              "originalPosition": 106,
              "body": "You need to say here that the AAD is an empty string.",
              "createdAt": "2021-01-18T21:37:39Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzg5MzM1",
          "commit": {
            "abbreviatedOid": "b13d8d4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T21:40:18Z",
          "updatedAt": "2021-01-18T21:40:19Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Maybe? But including the length is cheap, so why *not* do it?",
              "createdAt": "2021-01-18T21:40:19Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzg5NDg1",
          "commit": {
            "abbreviatedOid": "b13d8d4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T21:40:41Z",
          "updatedAt": "2021-01-18T21:40:42Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "That's fine -- separate issue?",
              "createdAt": "2021-01-18T21:40:41Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzkwNDEz",
          "commit": {
            "abbreviatedOid": "b13d8d4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T21:43:05Z",
          "updatedAt": "2021-01-18T21:43:06Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Sure: Nsk is the size of the KEM shared secret, not the AEAD encryption key. IIUC there's no difference between extracting the necessary amount and then stretching it (as we do here) or extracting something much larger and stretching.",
              "createdAt": "2021-01-18T21:43:06Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzkzNTMy",
          "commit": {
            "abbreviatedOid": "2c2fcf3"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T21:52:09Z",
          "updatedAt": "2021-01-18T21:52:09Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Oh, right.  I considered that, but didn't want to use that as encapsulation can make the value much larger than we might need.  X25519 is ok (32 bytes), but a P-256 share is larger, if only so that it can distinguish between compress and uncompressed.  Nsk might be larger in the sense that it contains wasted bits, but at least it is representative of the entropy level we are looking to maintain.",
              "createdAt": "2021-01-18T21:52:09Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzkzNjQ3",
          "commit": {
            "abbreviatedOid": "2c2fcf3"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T21:52:33Z",
          "updatedAt": "2021-01-18T21:52:33Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I just explained why: it makes it difficult to implement.",
              "createdAt": "2021-01-18T21:52:33Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzk0MDc1",
          "commit": {
            "abbreviatedOid": "2c2fcf3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T21:53:50Z",
          "updatedAt": "2021-01-18T21:53:50Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "My point is that the entropy we need is max(|key|, |nonce|), and Nk is exactly that for all AEADs I know of.",
              "createdAt": "2021-01-18T21:53:50Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzk0ODI4",
          "commit": {
            "abbreviatedOid": "2c2fcf3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T21:56:06Z",
          "updatedAt": "2021-01-18T21:56:07Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Yeah, I hear you, I'm just worried about what might happen if you don't authenticate the length explicitly. (I don't see any immediate problem, but I'd prefer we just explicitly authenticate every bit sent on the wire. I'm fine moving this to a separate issue.)",
              "createdAt": "2021-01-18T21:56:06Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzk1MTIz",
          "commit": {
            "abbreviatedOid": "2c2fcf3"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T21:56:52Z",
          "updatedAt": "2021-01-18T21:56:52Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "OK, fair enough.  In TLS we never reduced the entropy of a secret below that of the KDF, which this would do.  \r\n\r\nAnyway, could we say `max(Nk, Nn)` instead?",
              "createdAt": "2021-01-18T21:56:52Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzk1OTUy",
          "commit": {
            "abbreviatedOid": "e92b4f7"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T21:59:00Z",
          "updatedAt": "2021-01-18T21:59:01Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "If this were input to key schedule, sure.  But I'm not even sure we need to include the keyID in AAD at all.  It's convenient, so sure, but it isn't *necessary*.",
              "createdAt": "2021-01-18T21:59:01Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzk2MDYy",
          "commit": {
            "abbreviatedOid": "e92b4f7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T21:59:22Z",
          "updatedAt": "2021-01-18T21:59:22Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Reverted -- we can discussed separately in #12.",
              "createdAt": "2021-01-18T21:59:22Z",
              "updatedAt": "2021-01-18T22:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzk2Njg4",
          "commit": {
            "abbreviatedOid": "a21cda7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-18T22:01:11Z",
          "updatedAt": "2021-01-18T22:01:11Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Yep, done.",
              "createdAt": "2021-01-18T22:01:11Z",
              "updatedAt": "2021-01-18T22:01:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU3MDU4OTMy",
      "title": "Add Chris as author",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/14",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-18T22:06:04Z",
      "updatedAt": "2021-01-18T22:14:45Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "5c44c6dc243fe06314bbcc2be62a06e205a844b4",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "mt/caw",
      "headRefOid": "702c781abb8d79066cd1f2403a62e82146b6b1c3",
      "closedAt": "2021-01-18T22:08:10Z",
      "mergedAt": "2021-01-18T22:08:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "825f3f77549b69f62a3f5661c0b8b2d1e9151101"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU3MDk1NjY2",
      "title": "Define some HTTP usage",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/15",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is more or less implied already, but it is better to write it down.\r\n\r\nI've added stubs for some content types as well.",
      "createdAt": "2021-01-19T00:25:51Z",
      "updatedAt": "2021-01-22T02:35:35Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "825f3f77549b69f62a3f5661c0b8b2d1e9151101",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "http-usage",
      "headRefOid": "e645418316a3e4e6b80d520f8db125e8d171c704",
      "closedAt": "2021-01-22T02:35:34Z",
      "mergedAt": "2021-01-22T02:35:34Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "9abd4d3696e88c8b866bac2868d2fae5882b8be7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczNDkyMTYw",
          "commit": {
            "abbreviatedOid": "ad66a04"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-21T16:11:18Z",
          "updatedAt": "2021-01-21T16:23:13Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\ntarget URI of the oblivious proxy resource, a header field containing\r\n```",
              "createdAt": "2021-01-21T16:11:18Z",
              "updatedAt": "2021-01-22T02:25:49Z"
            },
            {
              "originalPosition": 19,
              "body": "Shouldn't the client also indicate the oblivious request resource URI (in a header or elsewhere)? If not, how does the proxy know where to forward the message?",
              "createdAt": "2021-01-21T16:14:29Z",
              "updatedAt": "2021-01-22T02:25:49Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\nwithout protection in response to the POST request made to that resource.\r\nOblivious request resources MUST use distinct status codes to distinguish \r\nHPKE key mismatch from other errors, such as decapsulation failure. This is\r\nneeded to inform clients of stale or otherwise incorrect HPKE keying material.\r\n```",
              "createdAt": "2021-01-21T16:22:21Z",
              "updatedAt": "2021-01-22T02:25:49Z"
            },
            {
              "originalPosition": 71,
              "body": "Feel free to include this in some other way, but I think it's important to note. Without a clear \"your key is out of date\" signal, clients don't know if and when they should fetch a fresh set of keys for encapsulation.",
              "createdAt": "2021-01-21T16:22:57Z",
              "updatedAt": "2021-01-22T02:25:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczNTI2OTE4",
          "commit": {
            "abbreviatedOid": "ad66a04"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-21T16:45:41Z",
          "updatedAt": "2021-01-21T16:45:41Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Oh, I see in #19 that it's assumed the proxy forwards to a fixed request resource, rather than letting the client choose (source routing style). Perhaps that can be the default if the request resource is omitted, allowing clients to control the path if desired? (That has security and policy implications though...)",
              "createdAt": "2021-01-21T16:45:41Z",
              "updatedAt": "2021-01-22T02:25:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczOTA0ODI5",
          "commit": {
            "abbreviatedOid": "ad66a04"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-22T02:21:48Z",
          "updatedAt": "2021-01-22T02:21:48Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Let's open an issue for this.  I think we want to recommend a status code for this, but it is possible that there isn't something easy we can use here (other than to maybe suggest that clients re-fetch key configuration when they get a non-encapsulated error response).",
              "createdAt": "2021-01-22T02:21:48Z",
              "updatedAt": "2021-01-22T02:25:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU4MDg1NTgw",
      "title": "Make the label match the text",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/17",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I think that \"response\" for the exporter is better than \"secret\".\r\nSymmetry.",
      "createdAt": "2021-01-20T09:17:12Z",
      "updatedAt": "2021-01-20T21:37:37Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "825f3f77549b69f62a3f5661c0b8b2d1e9151101",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "request-label",
      "headRefOid": "962643586678f84e58a14c62349126f5f71cd6da",
      "closedAt": "2021-01-20T21:37:36Z",
      "mergedAt": "2021-01-20T21:37:36Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "bceadaa805192029131e5cdd5a43dfd3d34f8cd8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyMTk3MTA0",
          "commit": {
            "abbreviatedOid": "9626435"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-20T13:02:41Z",
          "updatedAt": "2021-01-20T13:02:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "For HPKE we received a lot of feedback that it was most descriptive when the label matched the variable name, so how about:\r\n\r\n```suggestion\r\nresponse_secret = context.Export(\"response secret\", Nk)\r\n```\r\n\r\nOr something to that effect?",
              "createdAt": "2021-01-20T13:02:41Z",
              "updatedAt": "2021-01-20T13:02:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNjY4NTAz",
          "commit": {
            "abbreviatedOid": "9626435"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-20T21:33:51Z",
          "updatedAt": "2021-01-20T21:33:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I'm happy with the simple symmetry of using \"request\" to construct a request and \"response\" to construct a response.  Qualifying with \" secret\" implies that there are other things we might need for responses.\r\n\r\nThis is a simple enough process to follow that we probably don't need to be more explicit.",
              "createdAt": "2021-01-20T21:33:51Z",
              "updatedAt": "2021-01-20T21:33:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNjY5NDM5",
          "commit": {
            "abbreviatedOid": "9626435"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-20T21:35:14Z",
          "updatedAt": "2021-01-20T21:35:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\ud83d\udc4d I definitely don't feel strongly about this, other than that this label should (I think) be \"response\" since it's used to generate response encryption keys. ",
              "createdAt": "2021-01-20T21:35:14Z",
              "updatedAt": "2021-01-20T21:35:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU4MTY1NjA5",
      "title": "Fix Open variables",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/18",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-20T11:20:29Z",
      "updatedAt": "2021-01-20T13:00:46Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "825f3f77549b69f62a3f5661c0b8b2d1e9151101",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "response-ad",
      "headRefOid": "38d114d928a951579db6d3de6598c9bbc65a4fa9",
      "closedAt": "2021-01-20T13:00:45Z",
      "mergedAt": "2021-01-20T13:00:45Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "293db36eaee895289d1f4d6fe5a741cfb89992e7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyMTk1Mzk0",
          "commit": {
            "abbreviatedOid": "38d114d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-20T13:00:41Z",
          "updatedAt": "2021-01-20T13:00:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU5NjQwNzQz",
      "title": "Add KDF and AEAD identifiers to the message",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/22",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Switches to an 8-bit key identifier here as well.\r\n\r\nThis format now doesn't need varints.  Yay.\r\n\r\nImplemented this in my ohttp library and it's fine.\r\n\r\nCloses #20.",
      "createdAt": "2021-01-22T01:18:07Z",
      "updatedAt": "2021-01-23T01:55:42Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "6e86e49665a5d42364180ffde2c83919d4201e50",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "add-kdf-aead",
      "headRefOid": "dd3b77809971a5730fffc18bc4c89159d8420c6a",
      "closedAt": "2021-01-23T01:55:41Z",
      "mergedAt": "2021-01-23T01:55:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "400ed6fdba6f27232e00bf435c4cad3bbd259ece"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzIzMTAy",
          "commit": {
            "abbreviatedOid": "dd3b778"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-23T01:55:29Z",
          "updatedAt": "2021-01-23T01:55:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU5Njg1Mjk0",
      "title": "Define key configuration format",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/24",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I've also taken the time to review the text in the (now) security\r\nconsiderations and expand on some of the responsibilities.  Including\r\nthe one where the client needs to authenticate key configurations.\r\n\r\nCloses #21.",
      "createdAt": "2021-01-22T03:22:36Z",
      "updatedAt": "2021-01-23T01:46:48Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "9abd4d3696e88c8b866bac2868d2fae5882b8be7",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "key-format",
      "headRefOid": "9ad182455ef81ecb456e49a23977e9d8ec07af26",
      "closedAt": "2021-01-23T01:46:47Z",
      "mergedAt": "2021-01-23T01:46:47Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "99d4436dcf590a6bede7c644813fb291a95086fa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzEwMjYx",
          "commit": {
            "abbreviatedOid": "9ad1824"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-23T00:34:45Z",
          "updatedAt": "2021-01-23T00:34:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU5NzM3NDg3",
      "title": "Add acknowledgments",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/25",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Ack individuals here instead of citing?",
      "createdAt": "2021-01-22T06:08:44Z",
      "updatedAt": "2021-01-23T01:23:59Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "9abd4d3696e88c8b866bac2868d2fae5882b8be7",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "ack-a-little",
      "headRefOid": "aa27a190ad0063fc69c27019146279fe0a2a091a",
      "closedAt": "2021-01-23T01:23:58Z",
      "mergedAt": "2021-01-23T01:23:58Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "5a9b703e95bf33c1312c127011368d5d59e2b0ca"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Eh, the citing seems good.",
          "createdAt": "2021-01-23T00:35:21Z",
          "updatedAt": "2021-01-23T00:35:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzEwMzM4",
          "commit": {
            "abbreviatedOid": "aa27a19"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-23T00:35:05Z",
          "updatedAt": "2021-01-23T00:35:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU5NzQwMDA0",
      "title": "Use 422 for a key ID mismatch",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/26",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-22T06:14:57Z",
      "updatedAt": "2021-01-23T01:46:25Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "9abd4d3696e88c8b866bac2868d2fae5882b8be7",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "bad-content",
      "headRefOid": "d3994b90c867e33a510c2086ac9010f5e5366ede",
      "closedAt": "2021-01-23T01:46:24Z",
      "mergedAt": "2021-01-23T01:46:24Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "47b9df5175a9e0da142455e20bb08773cc2af7c3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzEwNTQ5",
          "commit": {
            "abbreviatedOid": "d3994b9"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-23T00:36:04Z",
          "updatedAt": "2021-01-23T00:36:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYwMzAzMDY5",
      "title": "Response of known length is 1",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/28",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "My implementation was wrong",
      "createdAt": "2021-01-23T02:40:25Z",
      "updatedAt": "2021-01-23T02:44:40Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "400ed6fdba6f27232e00bf435c4cad3bbd259ece",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "response-is-1",
      "headRefOid": "b7ac9838c37c099771b74f1324e54c5a69d28edd",
      "closedAt": "2021-01-23T02:44:39Z",
      "mergedAt": "2021-01-23T02:44:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f91751d3476fda528ea2b623786a924624d715f4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzI3OTcy",
          "commit": {
            "abbreviatedOid": "b7ac983"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-23T02:44:35Z",
          "updatedAt": "2021-01-23T02:44:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYwMzAzODUx",
      "title": "Clearer about interim responses",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/29",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-23T02:47:19Z",
      "updatedAt": "2021-01-23T02:48:25Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "f91751d3476fda528ea2b623786a924624d715f4",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "interim-response",
      "headRefOid": "0cd9012015ec000fb306f07835cbffb16ba4865b",
      "closedAt": "2021-01-23T02:48:24Z",
      "mergedAt": "2021-01-23T02:48:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4cee554a659e7dc01aa0c62403306264a3471f16"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NzI4Mjc0",
          "commit": {
            "abbreviatedOid": "0cd9012"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-23T02:48:20Z",
          "updatedAt": "2021-01-23T02:48:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYwNDM3Mzg5",
      "title": "Various nits found during implementation.",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/30",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "One question we might want to ask (even though I think we have the right answer already) is: should `kemID` be included in AAD?\r\n\r\nI also removed the padding text, since we moved that to the bhttp spec.",
      "createdAt": "2021-01-23T15:17:51Z",
      "updatedAt": "2021-01-24T13:34:29Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "4cee554a659e7dc01aa0c62403306264a3471f16",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "caw/nits",
      "headRefOid": "471df736482c6d6003a471a5008434af23a5645e",
      "closedAt": "2021-01-24T05:00:09Z",
      "mergedAt": "2021-01-24T05:00:08Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "b3ececa30ef580f98b0e1921121f715166db71a9"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "It's a reasonable question, but I think we can safely assume that a single key can't be used with multiple KEMs.",
          "createdAt": "2021-01-24T05:00:40Z",
          "updatedAt": "2021-01-24T05:00:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "In principle it might be possible, but I think we should prohibit it.\n\nOn Sat, Jan 23, 2021 at 9:00 PM Martin Thomson <notifications@github.com>\nwrote:\n\n> It's a reasonable question, but I think we can safely assume that a single\n> key can't be used with multiple KEMs.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/unicorn-wg/oblivious-http/pull/30#issuecomment-766291713>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIINCPE657SG4TP5VWTS3OSQHANCNFSM4WPYC6YQ>\n> .\n>\n",
          "createdAt": "2021-01-24T13:34:29Z",
          "updatedAt": "2021-01-24T13:34:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYxNDI2MjQx",
      "title": "Add self as author.",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/33",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-25T23:25:30Z",
      "updatedAt": "2021-01-25T23:25:30Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "b3ececa30ef580f98b0e1921121f715166db71a9",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "caw/add-chris",
      "headRefOid": "86db80fb3d1f827aee809d30532a7f867752305d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYxNDI3NjAz",
      "title": "Put the KEM ID before the key",
      "url": "https://github.com/unicorn-wg/oblivious-http/pull/34",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-25T23:29:11Z",
      "updatedAt": "2021-01-25T23:30:22Z",
      "baseRepository": "unicorn-wg/oblivious-http",
      "baseRefName": "main",
      "baseRefOid": "b3ececa30ef580f98b0e1921121f715166db71a9",
      "headRepository": "unicorn-wg/oblivious-http",
      "headRefName": "reorder-key-format",
      "headRefOid": "206e5daffab3a703f2c2d02e16e222be97804338",
      "closedAt": "2021-01-25T23:30:21Z",
      "mergedAt": "2021-01-25T23:30:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0d3c186cd51a2be63787becc0a1027ff5d04abab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1ODkyODY3",
          "commit": {
            "abbreviatedOid": "206e5da"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-25T23:29:51Z",
          "updatedAt": "2021-01-25T23:29:51Z",
          "comments": []
        }
      ]
    }
  ]
}