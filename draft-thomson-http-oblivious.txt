



HTTPBIS                                                       M. Thomson
Internet-Draft                                                   Mozilla
Intended status: Standards Track                         18 January 2021
Expires: 22 July 2021


                             Oblivious HTTP
                      draft-thomson-http-oblivious

Abstract

   This document describes a system for the forwarding of encrypted HTTP
   messages.  This allows clients to make requests of servers without
   the server being able to link requests to other requests from the
   same client.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the HTTP Working Group
   mailing list (http@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/http/.

   Source for this draft and an issue tracker can be found at
   https://github.com/unicorn-wg/oblivious-http.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 22 July 2021.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Overview
   4.  HPKE Encapsulation
     4.1.  HPKE Encapsulation of Requests
     4.2.  HPKE Encapsulation of Responses
     4.3.  Padding
   5.  Responsibility of Roles
     5.1.  Client
     5.2.  Oblivious Proxy Resource
     5.3.  Oblivious Request Resource
     5.4.  Oblivious Target Resource
   6.  Security Considerations
   7.  IANA Considerations
   8.  Normative References
   Acknowledgments
   Author's Address

1.  Introduction

   Words...

   This document describes a method of encapsulation for binary HTTP
   messages [BINARY] using Hybrid Public Key Encryption (HPKE; [HPKE]).

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   Encapsulated Request:  An HTTP request that is encapsulated in an
      HPKE-encrypted message; see Section 4.1.

   Encapsulated Response:  An HTTP response that is encapsulated in an
      HPKE-encrypted message; see Section 4.2.

   Oblivious Proxy Resource:  An intermediary that forwards requests and
      responses between clients and a single oblivious request resource.

   Oblivious Request Resource:  A resource that can receive an
      encapsulated request, extract the contents of that request,
      forward it to an oblivious target resource, receive a response,
      encapsulate that response, then return that response.

   Oblivious Target Resource:  The resource that is the target of an
      encapsulated request.  This resource logically handles only
      regular HTTP requests and responses and so might be ignorant of
      the use of oblivious HTTP to reach it.

3.  Overview

   A client learns the following:

   *  The identity of an oblivious request resource.  This might include
      some information about oblivious target resources that the
      oblivious request resource supports.

   *  The details of an HPKE public key that the oblivious request
      resource accepts, including an identifier for that key and the
      HPKE algorithms that are used with that key.

   *  The identity of an oblivious proxy resource that will forward
      encapsulated requests and responses to the oblivious request
      resource.

   This information allows the client to make a request of an oblivious
   target resource without that resource having only a limited ability
   to correlate that request with the client IP or other requests that
   the client might make to that server.

   +---------+        +----------+        +----------+    +----------+
   | Client  |        | Proxy    |        | Request  |    | Target   |
   |         |        | Resource |        | Resource |    | Resource |
   +---------+        +----------+        +----------+    +----------+
        |                  |                   |               |
        | Encapsulated     |                   |               |
        | Request          |                   |               |
        |----------------->| Encapsulated      |               |
        |                  | Request           |               |
        |                  |------------------>| Request       |
        |                  |                   |-------------->|
        |                  |                   |               |
        |                  |                   |      Response |
        |                  |      Encapsulated |<--------------|
        |                  |          Response |               |
        |     Encapsulated |<------------------|               |
        |         Response |                   |               |
        |<-----------------|                   |               |
        |                  |                   |               |

                    Figure 1: Overview of Oblivious HTTP

   In order to make a request to an oblivious target resource, the
   following steps occur, as shown in Figure 1:

   1.   The client constructs an HTTP request for an oblivious target
        resource.

   2.   The client encodes the HTTP request in a binary HTTP message and
        then encapsulates that message using HPKE and the process from
        Section 4.1.

   3.   The client sends a POST request to the oblivious proxy resource
        with the encapsulated request as the content of that message.

   4.   The oblivious proxy resource forwards this request to the
        oblivious request resource.

   5.   The oblivious request resource receives this request and removes
        the HPKE protection to obtain an HTTP request.

   6.   The oblivious request resource makes an HTTP request that
        includes the target URI, method, fields, and content of the
        request it acquires.

   7.   The oblivious target resource answers this HTTP request with an
        HTTP response.

   8.   The oblivious request resource encapsulates the HTTP response
        following the process in Section 4.2 and sends this in response
        to the request from the oblivious proxy resource.

   9.   The oblivious proxy resource forwards this response to the
        client.

   10.  The client removes the encapsulation to obtain the response to
        the original request.

4.  HPKE Encapsulation

   HTTP message encapsulation uses HPKE for request and response
   encryption.  An encapsulated HTTP message includes the following
   values:

   1.  A binary-encoded HTTP message [CITEME].

   2.  Padding of arbitrary length which MUST contain all zeroes.

   The encoding of an HTTP message is as follows:

   Plaintext Message {
     Message Length (i),
     Message (..),
     Padding Length (i),
     Padding (..),
   }

   This structure is then encrypted under a key with a specific
   identity, forming an encapsulated HTTP message, with the following
   structure:

   Key Identifer {
     Key ID Length (i),
     Key ID (..),
   }

   Encapsulated Message {
     Key Identifier (..)
     Encrypted Message Length (i),
     Encrypted Message (..),
   }

   The encapsulated message Key ID, as well as the encryption mechanics,
   are different for requests and responses, as described below.

4.1.  HPKE Encapsulation of Requests

   Clients encapsulate a request Plaintext Message "msg" with an HPKE
   public key "pkR", whose Key Identifier is "keyID" as follows:

   1.  Compute an HPKE context using "pkR", yielding "context" and
       encapsulation key "enc"

   2.  Encrypt (seal) "msg" with "keyID" as associated data using
       "context", yielding ciphertext "ct"

   3.  Concatenate "enc" and "ct", yielding an Encrypted Message
       "encrypted_msg"

   In pseudocode, this procedure is as follows:

   enc, context = SetupBaseS(pkR, "request")
   aad = 0x01 || keyID
   encrypted_msg = context.Seal(aad, msg)

   Clients construct the Encapsulated Message "req" using "keyID" and
   "encrypted_msg".

   Servers decrypt an Encapsulated Message by reversing this process.
   Given an Encapsulated Message "req" request with Key Identifier
   "keyID" corresponding to an existing HPKE private key "skR", servers
   decapsulate the Message as follows:

   1.  Parse the "req" Encrypted Message as the concatenation of "enc"
       and "encrypted_message"

   2.  Compute an HPKE context using "skR" and the encapsulated key
       "enc" from "req", yielding "context"

   3.  Decrypt "encrypted_message" with "keyID" as associated data,
       yielding "msg" or an error on failure

   In pseudocode, this procedure is as follows:

   context = SetupBaseR(enc, skR, "request")
   aad = 0x01 || keyID
   msg, error = context.Open(aad, ct)

   Servers MUST verify that the Plaintext Message padding consists of
   all zeroes before processing the corresponding Message.

4.2.  HPKE Encapsulation of Responses

   Given an HPKE context "context" and a response Plaintext Message
   "resp" sent in response to a Plaintext Message "req", servers encrypt
   the data as follows:

   1.  Derive a symmetric key and nonce from "context"

   2.  Encrypt "resp" with empty Key Identifier "emptyKeyID" as
       associated data, yielding "encrypted_msg"

   In pseudocode, this procedure is as follows:

   secret = context.Export("secret", 32)
   prk = Extract(req, secret)
   key = Expand(secret, "key", Nk)
   nonce = Expand(secret, "nonce", Nn)
   aad = 0x02 || emptyKeyID
   encrypted_msg = Seal(key, nonce, aad, resp)

   Extract and Expand are functions corresponding to the HPKE context's
   KDF algorithm, and Seal, Nk, and Nn correspond to the HPKE context's
   AEAD algorithm.

   Clients decrypt an Encapsulated Message by reversing this process.
   Namely, they derive the necessary AEAD parameters from an existing
   HPKE context and then decrypt (open) the Encapsulated Message
   encrypted message.

4.3.  Padding

   Plaintext Messages support arbitrary length padding.  Clients and
   servers MAY pad HTTP messages as needed to hide metadata leakage
   through ciphertext length.

5.  Responsibility of Roles

5.1.  Client

5.2.  Oblivious Proxy Resource

5.3.  Oblivious Request Resource

5.4.  Oblivious Target Resource

6.  Security Considerations

   Words...

7.  IANA Considerations

   TODO: Define a media type or types here.

8.  Normative References

   [BINARY]   Thomson, M., "Binary Representation of HTTP Messages",
              Work in Progress, Internet-Draft, draft-ietf-http-binary-
              message-latest, 18 January 2021,
              <https://tools.ietf.org/html/draft-ietf-http-binary-
              message-latest>.

   [HPKE]     Barnes, R., Bhargavan, K., Lipp, B., and C. Wood, "Hybrid
              Public Key Encryption", Work in Progress, Internet-Draft,
              draft-irtf-cfrg-hpke-07, 16 December 2020,
              <http://www.ietf.org/internet-drafts/draft-irtf-cfrg-hpke-
              07.txt>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

Acknowledgments

   TODO: credit where credit is due.

Author's Address

   Martin Thomson
   Mozilla

   Email: mt@lowentropy.net
